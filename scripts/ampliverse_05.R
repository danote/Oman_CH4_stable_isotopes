# Functions that work with amplicon data using tidyverse

#' @title Generate a tidy taxa table.
#' @description This function takes a dada2 sequence table,
#' a dada2 taxa table, and returns a tibble
#' in a tidy format.
#' @param seqtab_dada2 A dada2 sequence table.
#' @param taxa_dada2 A dada2 taxa table.
#' @return A tidy tibble with all the above data.
ampli_tidy_dada2 <- function(seqtab_dada2, taxa_dada2) {
  
  # convert DADA2 ASV table from matrix to tibble class, converting
  # rownames to column named "sample_id"
  seqtab_longer <- seqtab_dada2 %>% as_tibble(rownames = "sample_id") %>%
    # make table longer so that there are multiple rows for each sample,
    # each with a unique sequence for that sample
    pivot_longer(-sample_id, names_to = "sequence", values_to = "reads")
  
  # join taxonomic assignments by sequence
  seqtab_longer_taxa <- seqtab_longer %>%
    left_join(taxa_dada2 %>% as_tibble(rownames = "sequence"), by = "sequence")
}


#' @title Concatenate taxonomic levels into taxonomy string.
#' @description This function generates a new column with a taxonomy string extending to a
#' user-defined level.
#' @param ampli_tidy_tbl A tibble generated by ampli_tidy_dada2().
#' @param tax_levels The number of taxonomic levels to concatenate.
#' Default is 7: Kingdom, Phylum, Class, Order, Family, Genus, Species.
#' @param concat_tax_col_name The name desired for the newly generated column
#' @return A tidy tibble with a new column with the taxonomy string.
ampli_concat_tax <- function(ampli_tidy_tbl, tax_levels = 7, concat_tax_col_name = taxonomy) {
  
  if(tax_levels < 1 | tax_levels > 7 | tax_levels %>% near(round(tax_levels)) == FALSE) {
    stop("tax_levels must be a whole number between 1 and 7.")
  } else if (tax_levels == 1) {
    ampli_tidy_tbl <- ampli_tidy_tbl %>%
      mutate({{concat_tax_col_name}} := paste0("k__", Kingdom))
  } else if (tax_levels == 2) {
    ampli_tidy_tbl <- ampli_tidy_tbl %>%
      mutate({{concat_tax_col_name}} := paste0("k__", Kingdom, "; p__", Phylum))   
  } else if (tax_levels == 3) {
    ampli_tidy_tbl <- ampli_tidy_tbl %>%
      mutate({{concat_tax_col_name}} := paste0("k__", Kingdom, "; p__", Phylum,  "; c__", Class))
  } else if (tax_levels == 4) {
    ampli_tidy_tbl <- ampli_tidy_tbl %>%
      mutate({{concat_tax_col_name}} := paste0("k__", Kingdom, "; p__", Phylum,  "; c__", Class, "; o__", Order)) 
  } else if (tax_levels == 5) {
    ampli_tidy_tbl <- ampli_tidy_tbl %>%
      mutate({{concat_tax_col_name}} := paste0("k__", Kingdom, "; p__", Phylum,  "; c__", Class, "; o__", Order, "; f__", Family)) 
  } else if (tax_levels == 6) {
    ampli_tidy_tbl <- ampli_tidy_tbl %>%
      mutate({{concat_tax_col_name}} := paste0("k__", Kingdom, "; p__", Phylum,  "; c__", Class, "; o__", Order, "; f__", Family, "; g__", Genus)) 
  } else if (tax_levels == 7) {
    ampli_tidy_tbl <- ampli_tidy_tbl %>%
      mutate({{concat_tax_col_name}} := paste0("k__", Kingdom, "; p__", Phylum,  "; c__", Class, "; o__", Order, "; f__", Family, "; g__", Genus, "; s__", Species)) 
  }
}


#' @title Join metadata to an ampli_tidy_tbl.
#' @description This function joins a metadata "mapping" file,
#' in the form of a data frame, to an ampli_tidy_tbl.
#' @param map_df A mapping file data frame. It is assumed that a
#' sample identifier that corresponds to the dada2 seqtab is in
#' the first column of the mapping file.
#' @return A tidy tibble with all the above data.
ampli_join_metadata_map <- function(ampli_tidy_tbl, map_df) {
  
  # get mapping file in right format for joining
  map_df_rename <- as_tibble(map_df) %>% rename("sample_id" = 1)

  # join metadata by sample_id
  ampli_tidy_tbl <- ampli_tidy_tbl %>% left_join(map_df_rename, by = "sample_id")
}


#' @title Combine amplicon data tibbles.
#' @description This function uses dplyr::full_join() to combine amplicon tibbles  generated by ampli_tidy_dada2().  This function
#' should work if the metadata columns are different in different tibbles, but it might have issues if there are columns with the
#' same names, but different data types, so take care in parsing your metadata when loading it into R. This function should also
#' work even when the tibbles have non-unique sample ID's, but doing so increases risk of unexpected data processing downstream.
#' If you have some overlap in sample ID's in different data sets, consider generating a new column, perhaps using dplyr::mutate()
#' with a unique identifier, and move this the first column of the tibble. This may be most efficiently done (i.e. in one line of
#' code) after joining.
#' @param ampli_tidy_tbl_lst A list of tibbles generated by ampli_tidy_dada2() to join.
#' This can be generated with tibble::lst().
#' @return A single tibble containing the combined data in the provide list of amplicon data tibbles. 
ampli_join_ampli_tibbles <- function(ampli_tidy_tbl_lst) {
  
  purrr::reduce(ampli_tidy_tbl_lst, full_join)
}


#' @title Tally reads for each sample.
#' @description This function takes a tibble generated by ampli_tidy_dada2()
#' and returns a tibble with the sum of reads for each sample, and any other
#' desired metadata.
#' @param ampli_tidy_tbl A tibble generated by ampli_tidy_dada2().
#' @param cols_to_keep A character vector of column names to keep from the tibble.
#' @return A tibble with the sum of reads for each sample, and any other
#' desired metadata
ampli_tally_reads <- function(ampli_tidy_tbl, cols_to_keep = c()) {
  
  if (length(cols_to_keep) == 0) {
    ampli_tidy_tbl %>% group_by(sample_id) %>%
      summarise(reads_sum = sum(reads), .groups = "drop")
  } else {
    # arguments for including metadata in summarise()
    summarise_char_vector <- vector("character", length(cols_to_keep))
    for (i in seq_along(cols_to_keep)) {
      summarise_char_vector[[i]] = paste0(cols_to_keep[[i]], " = first(", cols_to_keep[[i]], ")")
    }
    
    # concatenate arguments into one vector
    summarise_char_vector_concat <- str_c(summarise_char_vector, collapse = ", ")
    
    # group tbl by sample_id
    ampli_tidy_tbl_grouped <- ampli_tidy_tbl %>% group_by(sample_id)
    
    # paste together elements of string to call summarise function
    call_str <- paste0("summarise(ampli_tidy_tbl_grouped, reads_sum = sum(reads), ", summarise_char_vector_concat , ", .groups = 'drop')")
    
    # evaluate call
      eval(str2lang(call_str))
    
  }
  }


#' @title Filter tbl by character string data. (e.g. taxa, sample name).
#' @description This function can be used to filter a tbl, such as one produced by ampli_tidy_dada2, for
#' any character string data. These include names of taxa and names of samples.
#' @param ampli_tidy_tbl A tibble, which can be generated by ampli_tidy_dada2().
#' @param col_to_filter Column in tibble to act upon, e.g. taxonomy or sample_id.
#' @param strings_to_filter Character vector of strings to search for in in data to filter.
#' @param detection_method One of "complete" or "substring". If "complete", a string in \code{strings_to_filter}
#' must completely match a string in the data to be filtered. If "substring", a string in \code{strings_to_filter}
#' may be a substring of a larger string in the data.
#' @param action One of "keep" or "remove". If a match is found, should the row be kept in the output, or removed?
#' @return A tibble with string matches kept or removed.
ampli_filter_strings <- function(ampli_tidy_tbl, col_to_filter, strings_to_filter, detection_method, action) {
  
  if (detection_method == "complete") {
    if (action == "keep") {
      ampli_tidy_tbl %>% filter({{col_to_filter}} %in% {{strings_to_filter}})
    } else if (action == "remove") {
      ampli_tidy_tbl %>% filter(!({{col_to_filter}} %in% {{strings_to_filter}}))
    } else {
      stop("Action unknown. Must be 'keep' or 'remove'.")
    }
  } else if (detection_method == "substring") {
    if (action == "keep") {
      ampli_tidy_tbl %>% filter({{col_to_filter}} %>% str_detect(paste({{strings_to_filter}}, collapse = '|')) == TRUE)
    } else if (action == "remove") {
      ampli_tidy_tbl %>% filter({{col_to_filter}} %>% str_detect(paste({{strings_to_filter}}, collapse = '|')) == FALSE)
    } else {
      stop("Action unknown. Must be 'keep' or 'remove'.")
    }
  } else {
      stop("Detection method unknown. Must be 'exact' or 'substring'.")
  }
}


#' @title Calculate relative abundances.
#' @description This function accepts a tibble generated by ampli_tidy_dada2() and adds
#' a column with total reads for the same and relative abundances of each sequence for each sample.
#' @param ampli_tidy_tbl A tibble generated by ampli_tidy_dada2().
#' @return A tibble with columns for total reads and relative abundances of reads of each sequence.
ampli_calc_rel_abund <- function(ampli_tidy_tbl) {
  
  ampli_tidy_tbl %>%
    # calculate read tallies and join
    left_join(ampli_tidy_tbl %>% ampli_tally_reads(), by = "sample_id") %>% 
    # calculate relative abundances
    mutate(rel_abund = reads/reads_sum) %>% 
    # reorder tibble to put the newly calculated columns (reads_sum and rel_abund) before other columns
    select(1:2, reads, reads_sum, rel_abund, everything())
}

#' @title Remove taxa that have zero reads from a data set.
#' @description If a subset of samples have been taken from a larger data set, it is possible that there
#' are taxa present in the subset that have zero reads (because they were only present in the samples that
#' comprised the original, larger data set). This can result in undesired plotting behavior. This function
#' removes these "zero-read" taxa.
#' @param ampli_tidy_tbl A tibble generated by ampli_tidy_dada2().
#' @param taxa_col_name Name of taxa column.
#' @param count_col_name Name of counts column.
#' @return A tibble with zero-read taxa removed.
ampli_rm_0_read_taxa <- function(ampli_tidy_tbl, taxa_col_name = sequence, read_col_name = reads) {
  
  # get a character vector of zero-read taxa
  zero_read_taxa_vect <- ampli_tidy_tbl %>%
    # group by taxa column
    group_by({{taxa_col_name}}) %>%
    # make column for sum of all reads of each taxa
    summarise(taxa_read_sum = sum({{read_col_name}}, na.rm = TRUE), .groups = "drop") %>%
    # filter for taxa with 0 reads
    filter(taxa_read_sum == 0) %>%
    # select only the taxa names from the data frame
    select({{taxa_col_name}}) %>%
    # convert to character vector
    as_vector(.type = "character")

  zero_read_taxa_count <- length(zero_read_taxa_vect)

  if(zero_read_taxa_count == 0) {
    message(paste(zero_read_taxa_count, "zero-read taxa found in data set."))
    ampli_tidy_tbl
  } else {
    message(paste(zero_read_taxa_count, "zero-read taxa removed from data set."))
    ampli_tidy_tbl %>%
      ampli_filter_strings(col_to_filter = {{taxa_col_name}}, strings_to_filter = zero_read_taxa_vect, detection_method = "complete", action = "remove")
  }
}


#' @title Plot heat map of taxa abundances.
#' @description This function accepts a tibble generated by ampli_tidy_dada2() and
#' generates a heat map based on e.g. read counts or relative abundances.
#' The output uses ggplot2 default styling, which is generally not suited for beautiful heat maps.
#' However, the styling can be readily adjusted with a few calls to ggplot2 scale_ or theme functions. Additionally,
#' abundance labels on top of the base geom_tile() plot must be manually added with \code{+ geom_text}.
#' The function was set up in this way so that the heavy data wrangling is done within the function to set
#' up the plot, whereas styling options are left to the user for maximum plot customizability.
#' @param ampli_tidy_tbl A tibble generated by ampli_tidy_dada2().
#' @param y_taxa_col The column within \code{ampli_tidy_tbl} to use for taxonomic names. This could be the full taxonomy string,
#' a taxonomic level (i.e. Phylum), or the complete sequence. This is generally plotted on the y axis.
#' @param x_sample_group_col The column within \code{ampli_tidy_tbl} to use for sample groupings. The default is \code{sample_id}, but
#' any data column could be used. This function will take care of grouping and normalizing abundances. This is generally plotted on the x axis.
#' LaTeX formatting can be applied using the \code{TeX} formatter function from the \code{latex2exp} package as
#' \code{ggplot2::scale_y_discrete(labels = TeX)}.
#' @param facet_grid_taxa_group_col [OPTIONAL] The column within \code{ampli_tidy_tbl} to use for \code{ggplot2::facet_grid}. This can be
#' used to group taxa by additional data, e.g. functional potentials. This is typically displayed on the right-side y-axis.
#' @param facet_grid_sample_group_col [OPTIONAL] The column within \code{ampli_tidy_tbl} to use for \code{ggplot2::facet_grid}. This can be
#' used to group samples by additional data, e.g. sampling date, sampling site, experimental group etc. This is typically displayed on the top
#' x-axis.
#' @param z_abundance_col The column within \code{ampli_tidy_tbl} to use for taxonomic abundances. Often, this will be \code{rel_abund} as
#' generated by \code{ampli_calc_rel_abund}.
#' @param col_to_weight_for_abund_summ The column to use for weighting summarized taxonomic abundances. Usually this will be sample_id (the default),
#' unless you are doing a more complex plot with pre-summarized data.
#' @param taxa_selection_method The method used to select which taxa to plot, one of "top_n", "threshold", or "custom_taxa_char_vector".
#' If "top_n" (the default), the top n (set in \code{top_n}) most abundant taxa. If "threshold", the threshold abundance (set by \code{treshold}), above
#' which to plot taxa. If "custom_taxa_char_vector", the selection of taxa supplied in \code{custom_taxa_char_vector}.
#' @param top_n The top number of most abundant taxa to plot, when \code{taxa_selection_method} is set to "top_n".
#' @param threshold The abundance threshold (with respect to the entire dataset, weighted by sample groupings) that determines whether a
#' a taxa is plotted, when \code{taxa_selection_method} is set to "threshold". If a taxa is below this threshold, it will be binned as "other".
#' @param custom_taxa_char_vector A character vector of taxa to plot, when \code{taxa_selection_method} is set to "custom_taxa_char_vector".
#' The function will search for matching strings in \code{y_taxa_col} that are the same length, or longer, than the strings provided in
#' \code{custom_taxa_char_vector} (i.e. searches are performed using \code{dplyr::subset}).
#' @param plot_other_taxa_bin If \code{TRUE}, a bin for the taxa that were not individually plotted is plotted.
#' @param return_plot_data_tbl If \code{TRUE}, a tbl of the data passed to \code{ggplot} is returned. This can be useful for
#' generating a \code{custom_taxa_names_tbl}.
#' @param custom_taxa_names_tbl [OPTIONAL] A tbl containing a column with the original taxa names to be plotted and a column containing custom names
#' to be plotted.
#' @param custom_taxa_names_col If \code{custom_taxa_names_tbl} is provided, the name of the column containing the custom taxa names. LaTeX
#' formatting can be applied using the \code{TeX} formatter function from the \code{latex2exp} package as
#' \code{ggplot2::scale_y_discrete(labels = TeX)}.
#' @param y_taxa_arrangement The arrangement (factor levels) in which taxa are plotted on the y axis. One of "alpha", "abund", or "custom". If "alpha",
#' the taxa will be arranged alphabetically ("a" on top). If "abund", the taxa will be arranged by the corresponding data provided in
#' \code{z_abundance_col}. If "custom", the user must provide a \code{custom_taxa_names_tbl}, in which the \code{custom_taxa_names_col} is a factor
#' with the desired levels.
#' @param facet_labeller The labeller function for the facet_grids.
#' @param other_taxa_name The name to use for bin of taxa that were not individually plotted.
#' @param NA_taxa_name The name to use when a given level of taxonomic classification (supplied by \code{y_taxa_col}) is \code{NA}. This typically
#' only applies when plotting a level of classification (e.g. Genus), as opposed to the full taxonomic string.
#' @param text_label_scalar Scalar to multiply \code{geom_text} abundance labels by. Set to 100 for percent.
#' @param text_label_decimal_places Sets the number of decimal places for \code{geom_text} abundance labels.
#' @param text_label_format Format of \code{geom_text} abundance labels.  One of "normal" or "scientific". If "scientific", when adding
#' \code{geom_text}, set \code{parse = TRUE}.
#' @param text_label_threshold Threshold of \code{z_abundance_col} below which to label as "<[threshold]". \code{text_label_threshold} should be supplied
#' in the same raw units as \code{z_abundance_col}. That is, \code{z_abundance_col} and \code{text_label_threshold} are both multiplied by \code{text_label_scalar}.
#' After scaling, \code{text_label_decimal_places} will also be applied to both \code{z_abundance_col} and \code{text_label_threshold}. \code{text_label_threshold}
#' only applies when \code{text_label_format} = "normal".
#' @param text_label_threshold_round_priority Should \code{text_label_threshold} be enforced before or after rounding to \code{text_label_decimal_places}?
#' The options are "round" to round first, or "threshold" to enforce the threshold first.
#' @param text_label_zero An alternative to "0" for labeling for samples with no reads of a given taxa. For example, it could be "n.r." for "no reads".
#' \code{text_label_zero} only applies when \code{text_label_format} = "normal".
#' @return A heat map in the form of a \code{ggplot2} object.
ampli_heat_map <- function(ampli_tidy_tbl, y_taxa_col = taxonomy, x_sample_group_col = sample_id, facet_grid_taxa_group_col = NULL,
                           facet_grid_sample_group_col = NULL, z_abundance_col = rel_abund, col_to_weight_for_abund_summ = sample_id,
                           taxa_selection_method = "top_n", top_n = 10, threshold = 0.03, custom_taxa_char_vector = NULL,
                           plot_other_taxa_bin = TRUE, return_plot_data_tbl = FALSE, custom_taxa_names_tbl = NULL, custom_taxa_names_col = NULL,
                           y_taxa_arrangement = "abund",
                           facet_labeller = label_value, other_taxa_name = "Other taxa", NA_taxa_name = "Unassigned", text_label_scalar = 1,
                           text_label_decimal_places = 2, text_label_format = "normal", text_label_threshold = NULL, text_label_zero = NULL,
                           text_label_threshold_round_priority = "round") {

    ### PREPARE DATA FOR PLOT ###
   
    # ungroup the ampli_tidy_tbl and select only the columns required for plotting
    ampli_tidy_tbl <- ampli_tidy_tbl %>%
      ungroup() %>%
      select({{col_to_weight_for_abund_summ}},  {{x_sample_group_col}}, {{facet_grid_sample_group_col}}, {{facet_grid_taxa_group_col}}, {{y_taxa_col}}, {{z_abundance_col}}) %>% 
      # mutate NA columns to so they are grouped appropriately for counting later on
      mutate("{{y_taxa_col}}" := if_else(is.na({{y_taxa_col}}), NA_taxa_name, {{y_taxa_col}}))
    
    # extract x_sample_group_col as character for later use with group_by()
    x_sample_group_col_char <- ampli_tidy_tbl %>% select({{x_sample_group_col}}) %>% colnames()

    # extract facet_grid_sample_group_col as character for later use with group_by()
    facet_grid_sample_group_col_char <- ampli_tidy_tbl %>% select({{facet_grid_sample_group_col}}) %>% colnames()
    
    # extract facet_grid_sample_group_col as character for later use
    facet_grid_taxa_group_col_char <- ampli_tidy_tbl %>% select({{facet_grid_taxa_group_col}}) %>% colnames()
    
    # extract y_taxa_col as character for later use with group_by()
    y_taxa_col_char <- ampli_tidy_tbl %>% select({{y_taxa_col}}) %>% colnames()
    
    # # extract y_taxa_col as character for later use with group_by()
    # col_to_weight_for_abund_summ_char <- ampli_tidy_tbl %>% select({{col_to_weight_for_abund_summ}}) %>% colnames()

    # summarize sample groupings, counting number of samples in each group
    ampli_tidy_tbl_sample_groupings_summ <- ampli_tidy_tbl %>%
      group_by({{x_sample_group_col}}, {{facet_grid_sample_group_col}}) %>%
      summarise(n_samples := n_distinct(as.character({{col_to_weight_for_abund_summ}})), .groups = "drop")
      # summarise("n_samples" = n_distinct({{col_to_weight_for_abund_summ}}), .groups = "drop")
    
    # return(ampli_tidy_tbl_sample_groupings_summ)
    
    # add number of samples per group to full tbl
    ampli_tidy_tbl_n_samples <- ampli_tidy_tbl %>%
      left_join(ampli_tidy_tbl_sample_groupings_summ, by = c(x_sample_group_col_char, facet_grid_sample_group_col_char))

    # generate observation structure for plot. Includes sample groupings and taxonomic groupings.
    obs_struc_for_plot <- ampli_tidy_tbl_n_samples %>%
      group_by({{x_sample_group_col}}, {{facet_grid_sample_group_col}}, {{y_taxa_col}}) %>%
      summarise("{{z_abundance_col}}" := sum({{z_abundance_col}}/n_samples), .groups = "drop")

    # summarize taxonomic abundances of full dataset, respecting sample groupings
    ampli_tidy_tbl_grouped_overall <- obs_struc_for_plot %>%
      group_by({{x_sample_group_col}}, {{facet_grid_sample_group_col}}, {{y_taxa_col}}) %>%
      summarize("{{z_abundance_col}}" := mean({{z_abundance_col}}), .groups = "drop") %>%
      group_by({{y_taxa_col}}) %>%
      summarize("{{z_abundance_col}}" := mean({{z_abundance_col}}), .groups = "drop")

    # selecting taxa to plot based on taxa_selection_method
    if (taxa_selection_method == "top_n") {

      # filter data for taxa with relative abundance greater than threshold
      ampli_tidy_tbl_grouped_overall_gt_th <- ampli_tidy_tbl_grouped_overall %>%
        slice_max(n = top_n, order_by = {{z_abundance_col}})

      # select the vector of taxa above threshold relative abundance
      gt_th_taxa <- ampli_tidy_tbl_grouped_overall_gt_th %>%
        select({{y_taxa_col}}) %>%
        as_vector()
      
      # filter for taxa above threshold
      ampli_tidy_tbl_gt_th <- obs_struc_for_plot %>%
        group_by({{y_taxa_col}}) %>%
        filter({{y_taxa_col}} %in% gt_th_taxa) %>%
        ungroup()

      if (plot_other_taxa_bin == FALSE){
        tax_table_for_heatmap <- ampli_tidy_tbl_gt_th
      } else {
        # filter taxa below threshold into "other" bin
        ampli_tidy_tbl_lt_th <- obs_struc_for_plot %>%
          group_by({{y_taxa_col}}) %>%
          filter(!({{y_taxa_col}} %in% gt_th_taxa)) %>%
          ungroup()

        other_sum <- ampli_tidy_tbl_lt_th %>%
          group_by({{x_sample_group_col}}, {{facet_grid_sample_group_col}}) %>%
          summarise("{{z_abundance_col}}" := sum({{z_abundance_col}}), .groups = "drop") %>%
          mutate({{y_taxa_col}} := other_taxa_name) %>%
          ungroup()

        # making a full table ready for heat map plotting
        # bind rows of taxa above threshold with "other" taxa and then add back in the metadata
        tax_table_for_heatmap <- ampli_tidy_tbl_gt_th %>% bind_rows(other_sum)
      }

    } else if (taxa_selection_method == "threshold") {

      # filter data for taxa with relative abundance greater than threshold
      ampli_tidy_tbl_grouped_overall_gt_th <- ampli_tidy_tbl_grouped_overall %>%
        filter({{z_abundance_col}} > threshold)

      # select the vector of taxa above threshold relative abundance
      gt_th_taxa <- ampli_tidy_tbl_grouped_overall_gt_th %>%
        select({{y_taxa_col}}) %>%
        as_vector()

      names(gt_th_taxa) <- NULL

      # filter for taxa above threshold
      ampli_tidy_tbl_gt_th <- obs_struc_for_plot %>%
        group_by({{y_taxa_col}}) %>%
        filter({{y_taxa_col}} %in% gt_th_taxa) %>%
        ungroup()

      if (plot_other_taxa_bin == FALSE){
        tax_table_for_heatmap <- ampli_tidy_tbl_gt_th
      } else {
        # filter taxa below threshold into other bin
        ampli_tidy_tbl_lt_th <- obs_struc_for_plot %>%
          group_by({{y_taxa_col}}) %>%
          filter({{y_taxa_col}} %in% gt_th_taxa) %>%
          ungroup()

        other_sum <- ampli_tidy_tbl_lt_th %>%
          group_by({{x_sample_group_col}}, {{facet_grid_sample_group_col}}) %>%
          summarise("{{z_abundance_col}}" := sum({{z_abundance_col}})) %>%
          mutate({{y_taxa_col}} := other_taxa_name) %>%
          ungroup()

        # making a full table ready for heatmap plotting
        # bind rows of taxa above threshold with other taxa and then add back in the metadata
        tax_table_for_heatmap <- ampli_tidy_tbl_gt_th %>% bind_rows(other_sum)
      }

    } else if (taxa_selection_method == "custom_taxa_char_vector") {

      # filter for taxa above threshold
      ampli_tidy_tbl_to_plot <- obs_struc_for_plot %>%
        group_by({{y_taxa_col}}) %>%
        filter({{y_taxa_col}} %>% str_detect(paste(custom_taxa_char_vector, collapse = '|')) == TRUE) %>% 
        ungroup()

      if (plot_other_taxa_bin == FALSE){
        tax_table_for_heatmap <- ampli_tidy_tbl_to_plot
      } else {
        # filter taxa below threshold into "other" bin
        ampli_tidy_tbl_not_to_plot <- obs_struc_for_plot %>%
          group_by({{y_taxa_col}}) %>%
          filter({{y_taxa_col}} %>% str_detect(paste(custom_taxa_char_vector, collapse = '|')) == FALSE) %>% 
          ungroup()

        other_sum <- ampli_tidy_tbl_not_to_plot %>%
          group_by({{x_sample_group_col}}, {{facet_grid_sample_group_col}}) %>%
          summarise("{{z_abundance_col}}" := sum({{z_abundance_col}})) %>%
          mutate({{y_taxa_col}} := name_to_show_for_other_taxa) %>%
          ungroup()

        # making a full table ready for heatmap plotting
        # bind rows of taxa above threshold with other taxa and then add back in the metadata
        tax_table_for_heatmap <- ampli_tidy_tbl_to_plot %>% bind_rows(other_sum)
      }
    } else {
      stop("Unknown taxa selection method.")
    }
    
    #  add taxa facet grid column to tax_table_for_heatmap
    if (length(facet_grid_taxa_group_col_char) != 0){
      tax_table_for_heatmap <- tax_table_for_heatmap %>%
        left_join(ampli_tidy_tbl %>% group_by({{y_taxa_col}}) %>% summarise("{{facet_grid_taxa_group_col}}" := first({{facet_grid_taxa_group_col}})), by = y_taxa_col_char)
    }
    
      #  add custom taxa names, if provided
      if (!is.null(custom_taxa_names_tbl)){

        tax_table_for_heatmap <- tax_table_for_heatmap %>%
          # add custom taxa names to tax_table_for_heatmap
          left_join(custom_taxa_names_tbl %>% select({{y_taxa_col}}, {{custom_taxa_names_col}}), by = y_taxa_col_char) %>% 
          # # drop original taxa names
          select(-{{y_taxa_col}}) %>% 
          # rename custom taxa names column with the original taxa name column name
          # this makes it easier to work with both the cases in which a custom taxa name
          # or a default taxa name are used
        rename({{y_taxa_col}} := {{custom_taxa_names_col}})
      }
    

    
    # add taxa name ordering
    if (y_taxa_arrangement == "abund"){
      # create a summary of relative abundances of taxa, grouped by taxa (independent of sample)
      tax_table_for_heatmap_tax_group_abund_summ <- tax_table_for_heatmap %>%
        ungroup() %>%
        group_by({{y_taxa_col}}) %>%
        # using sum with na.rm here so that this will work even if data are not present for certain taxonomic levels
        summarise(overall_abundance_sum = sum({{z_abundance_col}}, na.rm = TRUE), .groups = "drop")
      
      # add summarized abundance column to tax_table_for_heatmap
      tax_table_for_heatmap <- tax_table_for_heatmap %>%
        left_join(
          tax_table_for_heatmap_tax_group_abund_summ, by = y_taxa_col_char
        )
      
      # make y taxa column into a factor and order it by overall abundance, moving "other taxa" bin to bottom for plotting
      tax_table_for_heatmap <- tax_table_for_heatmap %>%
        mutate({{y_taxa_col}} := {{y_taxa_col}} %>% as_factor() %>% fct_reorder(overall_abundance_sum) %>% fct_relevel(other_taxa_name)) %>%
        # drop overall abundance from table
        select(-overall_abundance_sum)
      
    } else if (y_taxa_arrangement == "alpha"){
      # reset factor levels of y taxa column and put them in reverse alphabetical order for plotting.
      tax_table_for_heatmap <- tax_table_for_heatmap %>%
        mutate({{y_taxa_col}} := {{y_taxa_col}} %>% as_character() %>% as_factor() %>% fct_rev())


    } else if (y_taxa_arrangement != "custom"){
      stop("y_taxa_arrangement invalid or not provided.")
    }

      # format geom_text labels
      
      if (text_label_format == "normal"){
        
        if (is.null(text_label_threshold) &  is.null(text_label_zero)){
          tax_table_for_heatmap <- tax_table_for_heatmap %>%
          mutate(z_text_label = round({{z_abundance_col}} * text_label_scalar, text_label_decimal_places))
        } else if (!is.null(text_label_threshold) & is.null(text_label_zero)){
          if (text_label_threshold_round_priority == "round"){
            tax_table_for_heatmap <- tax_table_for_heatmap %>%
              mutate(z_text_label = if_else(round({{z_abundance_col}} * text_label_scalar, text_label_decimal_places) >= round({{text_label_threshold}} * text_label_scalar, text_label_decimal_places), as.character(round({{z_abundance_col}} * text_label_scalar, text_label_decimal_places)),
                                            paste0("<", round(text_label_threshold * text_label_scalar, text_label_decimal_places))))
          } else if (text_label_threshold_round_priority == "threshold") {
            tax_table_for_heatmap <- tax_table_for_heatmap %>%
              mutate(z_text_label = if_else({{z_abundance_col}} >= text_label_threshold, as.character(round({{z_abundance_col}} * text_label_scalar, text_label_decimal_places)),
                                            paste0("<", round(text_label_threshold * text_label_scalar, text_label_decimal_places))))
          } else {
            stop("text_label_threshold_round_priority invalid. Must be one of 'round' or 'threshold'.")
          }
        } else if (is.null(text_label_threshold) & !is.null(text_label_zero)){
            tax_table_for_heatmap <- tax_table_for_heatmap %>%
              mutate(z_text_label = if_else({{z_abundance_col}} != 0, as.character(round({{z_abundance_col}} * text_label_scalar, text_label_decimal_places)), as.character(text_label_zero)))
        } else if (!is.null(text_label_threshold) & !is.null(text_label_zero)){
          if (text_label_threshold_round_priority == "round"){
            tax_table_for_heatmap <- tax_table_for_heatmap %>%
              mutate(z_text_label = case_when(
                round({{z_abundance_col}} * text_label_scalar, text_label_decimal_places) >= round({{text_label_threshold}} * text_label_scalar, text_label_decimal_places) ~ as.character(round({{z_abundance_col}} * text_label_scalar, text_label_decimal_places)),
                {{z_abundance_col}} != 0 & round({{z_abundance_col}} * text_label_scalar, text_label_decimal_places) < round({{text_label_threshold}} * text_label_scalar, text_label_decimal_places) ~ paste0("<", round(text_label_threshold * text_label_scalar, text_label_decimal_places)),
                {{z_abundance_col}} == 0 ~ as.character(text_label_zero)))
          } else if (text_label_threshold_round_priority == "threshold") {
            tax_table_for_heatmap <- tax_table_for_heatmap %>%
              mutate(z_text_label = case_when(
                {{z_abundance_col}} >= text_label_threshold ~ as.character(round({{z_abundance_col}} * text_label_scalar, text_label_decimal_places)),
                {{z_abundance_col}} != 0 & {{z_abundance_col}} < text_label_threshold ~ paste0("<", round(text_label_threshold * text_label_scalar, text_label_decimal_places)),
                {{z_abundance_col}} == 0 ~ as.character(text_label_zero)))
          } else {
            stop("text_label_threshold_round_priority invalid. Must be one of 'round' or 'threshold'.")
          }
        }
          
          } else if (text_label_format == "scientific"){
        # make scientific formatter function
        num_to_sci_10_for_plotmath_parser <- function(x, digits = 3, scale = 1, digits_if_0 = 1){
          if(digits_if_0 < 1 | digits_if_0 != round(digits_if_0)){
            stop("digits_if_0 must be a whole number > 0")
          }
          if_else(x == 0,
                  paste0("'", "0", ".", seq.int(from = 0, to = 0, length.out = (digits_if_0 - 1)) %>% str_c(collapse = ""), "'"),
                  paste0("'", gsub("[+]", "", gsub("e", "' %.% 10^", sprintf(paste0("%.", (digits) , "e"), x * scale)))))
        }
        tax_table_for_heatmap <- tax_table_for_heatmap %>%
            mutate(z_text_label = {{z_abundance_col}} %>%
                     num_to_sci_10_for_plotmath_parser(digits = text_label_decimal_places, scale = text_label_scalar, digits_if_0 = text_label_decimal_places + 1))
      } else {
        stop("Invalid text_label_format. Must be one of 'normal' or 'scientific'.")
      }
     
    
    # return plotted taxa names tbl, if requested
    if (return_plot_data_tbl == TRUE){
      return(tax_table_for_heatmap)
    } 
    
      ### PLOT ###

      # set variables to plot
      tax_table_for_heatmap %>% ggplot(aes(
        x = {{x_sample_group_col}},
        y = {{y_taxa_col}},
        fill = {{z_abundance_col}},
        label = z_text_label
      )) +
        # plot geometry
        geom_tile() +
        
        facet_grid(cols = vars({{facet_grid_sample_group_col}}), rows = vars({{facet_grid_taxa_group_col}}), scales = "free", space = "free", labeller = facet_labeller)
}